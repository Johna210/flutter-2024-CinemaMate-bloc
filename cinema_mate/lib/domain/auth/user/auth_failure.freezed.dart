// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'auth_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AuthFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailOrPassword,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() tokenExpired,
    required TResult Function() userNotFound,
    required TResult Function() notSignedIn,
    required TResult Function() accountSuspended,
    required TResult Function() wrongPassword,
    required TResult Function() wrongUsername,
    required TResult Function() passwordsDoesntMatch,
    required TResult Function() wrongEmail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? serverError,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailOrPassword,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? tokenExpired,
    TResult? Function()? userNotFound,
    TResult? Function()? notSignedIn,
    TResult? Function()? accountSuspended,
    TResult? Function()? wrongPassword,
    TResult? Function()? wrongUsername,
    TResult? Function()? passwordsDoesntMatch,
    TResult? Function()? wrongEmail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailOrPassword,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? tokenExpired,
    TResult Function()? userNotFound,
    TResult Function()? notSignedIn,
    TResult Function()? accountSuspended,
    TResult Function()? wrongPassword,
    TResult Function()? wrongUsername,
    TResult Function()? passwordsDoesntMatch,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerError value) serverError,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(InvalidEmailOrPassword value)
        invalidEmailOrPassword,
    required TResult Function(UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(TokenExpired value) tokenExpired,
    required TResult Function(UserNotFound value) userNotFound,
    required TResult Function(NotSignedIn value) notSignedIn,
    required TResult Function(AccountSuspended value) accountSuspended,
    required TResult Function(WrongPassword value) wrongPassword,
    required TResult Function(WrongUsername value) wrongUsername,
    required TResult Function(PasswordsDoesntMatch value) passwordsDoesntMatch,
    required TResult Function(WrongEmail value) wrongEmail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServerError value)? serverError,
    TResult? Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult? Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(TokenExpired value)? tokenExpired,
    TResult? Function(UserNotFound value)? userNotFound,
    TResult? Function(NotSignedIn value)? notSignedIn,
    TResult? Function(AccountSuspended value)? accountSuspended,
    TResult? Function(WrongPassword value)? wrongPassword,
    TResult? Function(WrongUsername value)? wrongUsername,
    TResult? Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult? Function(WrongEmail value)? wrongEmail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerError value)? serverError,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(TokenExpired value)? tokenExpired,
    TResult Function(UserNotFound value)? userNotFound,
    TResult Function(NotSignedIn value)? notSignedIn,
    TResult Function(AccountSuspended value)? accountSuspended,
    TResult Function(WrongPassword value)? wrongPassword,
    TResult Function(WrongUsername value)? wrongUsername,
    TResult Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthFailureCopyWith<$Res> {
  factory $AuthFailureCopyWith(
          AuthFailure value, $Res Function(AuthFailure) then) =
      _$AuthFailureCopyWithImpl<$Res, AuthFailure>;
}

/// @nodoc
class _$AuthFailureCopyWithImpl<$Res, $Val extends AuthFailure>
    implements $AuthFailureCopyWith<$Res> {
  _$AuthFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ServerErrorImplCopyWith<$Res> {
  factory _$$ServerErrorImplCopyWith(
          _$ServerErrorImpl value, $Res Function(_$ServerErrorImpl) then) =
      __$$ServerErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServerErrorImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$ServerErrorImpl>
    implements _$$ServerErrorImplCopyWith<$Res> {
  __$$ServerErrorImplCopyWithImpl(
      _$ServerErrorImpl _value, $Res Function(_$ServerErrorImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ServerErrorImpl implements ServerError {
  const _$ServerErrorImpl();

  @override
  String toString() {
    return 'AuthFailure.serverError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ServerErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailOrPassword,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() tokenExpired,
    required TResult Function() userNotFound,
    required TResult Function() notSignedIn,
    required TResult Function() accountSuspended,
    required TResult Function() wrongPassword,
    required TResult Function() wrongUsername,
    required TResult Function() passwordsDoesntMatch,
    required TResult Function() wrongEmail,
  }) {
    return serverError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? serverError,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailOrPassword,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? tokenExpired,
    TResult? Function()? userNotFound,
    TResult? Function()? notSignedIn,
    TResult? Function()? accountSuspended,
    TResult? Function()? wrongPassword,
    TResult? Function()? wrongUsername,
    TResult? Function()? passwordsDoesntMatch,
    TResult? Function()? wrongEmail,
  }) {
    return serverError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailOrPassword,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? tokenExpired,
    TResult Function()? userNotFound,
    TResult Function()? notSignedIn,
    TResult Function()? accountSuspended,
    TResult Function()? wrongPassword,
    TResult Function()? wrongUsername,
    TResult Function()? passwordsDoesntMatch,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerError value) serverError,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(InvalidEmailOrPassword value)
        invalidEmailOrPassword,
    required TResult Function(UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(TokenExpired value) tokenExpired,
    required TResult Function(UserNotFound value) userNotFound,
    required TResult Function(NotSignedIn value) notSignedIn,
    required TResult Function(AccountSuspended value) accountSuspended,
    required TResult Function(WrongPassword value) wrongPassword,
    required TResult Function(WrongUsername value) wrongUsername,
    required TResult Function(PasswordsDoesntMatch value) passwordsDoesntMatch,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServerError value)? serverError,
    TResult? Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult? Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(TokenExpired value)? tokenExpired,
    TResult? Function(UserNotFound value)? userNotFound,
    TResult? Function(NotSignedIn value)? notSignedIn,
    TResult? Function(AccountSuspended value)? accountSuspended,
    TResult? Function(WrongPassword value)? wrongPassword,
    TResult? Function(WrongUsername value)? wrongUsername,
    TResult? Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult? Function(WrongEmail value)? wrongEmail,
  }) {
    return serverError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerError value)? serverError,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(TokenExpired value)? tokenExpired,
    TResult Function(UserNotFound value)? userNotFound,
    TResult Function(NotSignedIn value)? notSignedIn,
    TResult Function(AccountSuspended value)? accountSuspended,
    TResult Function(WrongPassword value)? wrongPassword,
    TResult Function(WrongUsername value)? wrongUsername,
    TResult Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class ServerError implements AuthFailure {
  const factory ServerError() = _$ServerErrorImpl;
}

/// @nodoc
abstract class _$$EmailAlreadyInUseImplCopyWith<$Res> {
  factory _$$EmailAlreadyInUseImplCopyWith(_$EmailAlreadyInUseImpl value,
          $Res Function(_$EmailAlreadyInUseImpl) then) =
      __$$EmailAlreadyInUseImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmailAlreadyInUseImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$EmailAlreadyInUseImpl>
    implements _$$EmailAlreadyInUseImplCopyWith<$Res> {
  __$$EmailAlreadyInUseImplCopyWithImpl(_$EmailAlreadyInUseImpl _value,
      $Res Function(_$EmailAlreadyInUseImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EmailAlreadyInUseImpl implements EmailAlreadyInUse {
  const _$EmailAlreadyInUseImpl();

  @override
  String toString() {
    return 'AuthFailure.emailAlreadyInUse()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EmailAlreadyInUseImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailOrPassword,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() tokenExpired,
    required TResult Function() userNotFound,
    required TResult Function() notSignedIn,
    required TResult Function() accountSuspended,
    required TResult Function() wrongPassword,
    required TResult Function() wrongUsername,
    required TResult Function() passwordsDoesntMatch,
    required TResult Function() wrongEmail,
  }) {
    return emailAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? serverError,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailOrPassword,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? tokenExpired,
    TResult? Function()? userNotFound,
    TResult? Function()? notSignedIn,
    TResult? Function()? accountSuspended,
    TResult? Function()? wrongPassword,
    TResult? Function()? wrongUsername,
    TResult? Function()? passwordsDoesntMatch,
    TResult? Function()? wrongEmail,
  }) {
    return emailAlreadyInUse?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailOrPassword,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? tokenExpired,
    TResult Function()? userNotFound,
    TResult Function()? notSignedIn,
    TResult Function()? accountSuspended,
    TResult Function()? wrongPassword,
    TResult Function()? wrongUsername,
    TResult Function()? passwordsDoesntMatch,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerError value) serverError,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(InvalidEmailOrPassword value)
        invalidEmailOrPassword,
    required TResult Function(UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(TokenExpired value) tokenExpired,
    required TResult Function(UserNotFound value) userNotFound,
    required TResult Function(NotSignedIn value) notSignedIn,
    required TResult Function(AccountSuspended value) accountSuspended,
    required TResult Function(WrongPassword value) wrongPassword,
    required TResult Function(WrongUsername value) wrongUsername,
    required TResult Function(PasswordsDoesntMatch value) passwordsDoesntMatch,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return emailAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServerError value)? serverError,
    TResult? Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult? Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(TokenExpired value)? tokenExpired,
    TResult? Function(UserNotFound value)? userNotFound,
    TResult? Function(NotSignedIn value)? notSignedIn,
    TResult? Function(AccountSuspended value)? accountSuspended,
    TResult? Function(WrongPassword value)? wrongPassword,
    TResult? Function(WrongUsername value)? wrongUsername,
    TResult? Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult? Function(WrongEmail value)? wrongEmail,
  }) {
    return emailAlreadyInUse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerError value)? serverError,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(TokenExpired value)? tokenExpired,
    TResult Function(UserNotFound value)? userNotFound,
    TResult Function(NotSignedIn value)? notSignedIn,
    TResult Function(AccountSuspended value)? accountSuspended,
    TResult Function(WrongPassword value)? wrongPassword,
    TResult Function(WrongUsername value)? wrongUsername,
    TResult Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class EmailAlreadyInUse implements AuthFailure {
  const factory EmailAlreadyInUse() = _$EmailAlreadyInUseImpl;
}

/// @nodoc
abstract class _$$InvalidEmailOrPasswordImplCopyWith<$Res> {
  factory _$$InvalidEmailOrPasswordImplCopyWith(
          _$InvalidEmailOrPasswordImpl value,
          $Res Function(_$InvalidEmailOrPasswordImpl) then) =
      __$$InvalidEmailOrPasswordImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InvalidEmailOrPasswordImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$InvalidEmailOrPasswordImpl>
    implements _$$InvalidEmailOrPasswordImplCopyWith<$Res> {
  __$$InvalidEmailOrPasswordImplCopyWithImpl(
      _$InvalidEmailOrPasswordImpl _value,
      $Res Function(_$InvalidEmailOrPasswordImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InvalidEmailOrPasswordImpl implements InvalidEmailOrPassword {
  const _$InvalidEmailOrPasswordImpl();

  @override
  String toString() {
    return 'AuthFailure.invalidEmailOrPassword()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidEmailOrPasswordImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailOrPassword,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() tokenExpired,
    required TResult Function() userNotFound,
    required TResult Function() notSignedIn,
    required TResult Function() accountSuspended,
    required TResult Function() wrongPassword,
    required TResult Function() wrongUsername,
    required TResult Function() passwordsDoesntMatch,
    required TResult Function() wrongEmail,
  }) {
    return invalidEmailOrPassword();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? serverError,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailOrPassword,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? tokenExpired,
    TResult? Function()? userNotFound,
    TResult? Function()? notSignedIn,
    TResult? Function()? accountSuspended,
    TResult? Function()? wrongPassword,
    TResult? Function()? wrongUsername,
    TResult? Function()? passwordsDoesntMatch,
    TResult? Function()? wrongEmail,
  }) {
    return invalidEmailOrPassword?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailOrPassword,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? tokenExpired,
    TResult Function()? userNotFound,
    TResult Function()? notSignedIn,
    TResult Function()? accountSuspended,
    TResult Function()? wrongPassword,
    TResult Function()? wrongUsername,
    TResult Function()? passwordsDoesntMatch,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (invalidEmailOrPassword != null) {
      return invalidEmailOrPassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerError value) serverError,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(InvalidEmailOrPassword value)
        invalidEmailOrPassword,
    required TResult Function(UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(TokenExpired value) tokenExpired,
    required TResult Function(UserNotFound value) userNotFound,
    required TResult Function(NotSignedIn value) notSignedIn,
    required TResult Function(AccountSuspended value) accountSuspended,
    required TResult Function(WrongPassword value) wrongPassword,
    required TResult Function(WrongUsername value) wrongUsername,
    required TResult Function(PasswordsDoesntMatch value) passwordsDoesntMatch,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return invalidEmailOrPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServerError value)? serverError,
    TResult? Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult? Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(TokenExpired value)? tokenExpired,
    TResult? Function(UserNotFound value)? userNotFound,
    TResult? Function(NotSignedIn value)? notSignedIn,
    TResult? Function(AccountSuspended value)? accountSuspended,
    TResult? Function(WrongPassword value)? wrongPassword,
    TResult? Function(WrongUsername value)? wrongUsername,
    TResult? Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult? Function(WrongEmail value)? wrongEmail,
  }) {
    return invalidEmailOrPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerError value)? serverError,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(TokenExpired value)? tokenExpired,
    TResult Function(UserNotFound value)? userNotFound,
    TResult Function(NotSignedIn value)? notSignedIn,
    TResult Function(AccountSuspended value)? accountSuspended,
    TResult Function(WrongPassword value)? wrongPassword,
    TResult Function(WrongUsername value)? wrongUsername,
    TResult Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (invalidEmailOrPassword != null) {
      return invalidEmailOrPassword(this);
    }
    return orElse();
  }
}

abstract class InvalidEmailOrPassword implements AuthFailure {
  const factory InvalidEmailOrPassword() = _$InvalidEmailOrPasswordImpl;
}

/// @nodoc
abstract class _$$UsernameAlreadyInUseImplCopyWith<$Res> {
  factory _$$UsernameAlreadyInUseImplCopyWith(_$UsernameAlreadyInUseImpl value,
          $Res Function(_$UsernameAlreadyInUseImpl) then) =
      __$$UsernameAlreadyInUseImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UsernameAlreadyInUseImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$UsernameAlreadyInUseImpl>
    implements _$$UsernameAlreadyInUseImplCopyWith<$Res> {
  __$$UsernameAlreadyInUseImplCopyWithImpl(_$UsernameAlreadyInUseImpl _value,
      $Res Function(_$UsernameAlreadyInUseImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UsernameAlreadyInUseImpl implements UsernameAlreadyInUse {
  const _$UsernameAlreadyInUseImpl();

  @override
  String toString() {
    return 'AuthFailure.usernameAlreadyInUse()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UsernameAlreadyInUseImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailOrPassword,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() tokenExpired,
    required TResult Function() userNotFound,
    required TResult Function() notSignedIn,
    required TResult Function() accountSuspended,
    required TResult Function() wrongPassword,
    required TResult Function() wrongUsername,
    required TResult Function() passwordsDoesntMatch,
    required TResult Function() wrongEmail,
  }) {
    return usernameAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? serverError,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailOrPassword,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? tokenExpired,
    TResult? Function()? userNotFound,
    TResult? Function()? notSignedIn,
    TResult? Function()? accountSuspended,
    TResult? Function()? wrongPassword,
    TResult? Function()? wrongUsername,
    TResult? Function()? passwordsDoesntMatch,
    TResult? Function()? wrongEmail,
  }) {
    return usernameAlreadyInUse?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailOrPassword,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? tokenExpired,
    TResult Function()? userNotFound,
    TResult Function()? notSignedIn,
    TResult Function()? accountSuspended,
    TResult Function()? wrongPassword,
    TResult Function()? wrongUsername,
    TResult Function()? passwordsDoesntMatch,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (usernameAlreadyInUse != null) {
      return usernameAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerError value) serverError,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(InvalidEmailOrPassword value)
        invalidEmailOrPassword,
    required TResult Function(UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(TokenExpired value) tokenExpired,
    required TResult Function(UserNotFound value) userNotFound,
    required TResult Function(NotSignedIn value) notSignedIn,
    required TResult Function(AccountSuspended value) accountSuspended,
    required TResult Function(WrongPassword value) wrongPassword,
    required TResult Function(WrongUsername value) wrongUsername,
    required TResult Function(PasswordsDoesntMatch value) passwordsDoesntMatch,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return usernameAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServerError value)? serverError,
    TResult? Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult? Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(TokenExpired value)? tokenExpired,
    TResult? Function(UserNotFound value)? userNotFound,
    TResult? Function(NotSignedIn value)? notSignedIn,
    TResult? Function(AccountSuspended value)? accountSuspended,
    TResult? Function(WrongPassword value)? wrongPassword,
    TResult? Function(WrongUsername value)? wrongUsername,
    TResult? Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult? Function(WrongEmail value)? wrongEmail,
  }) {
    return usernameAlreadyInUse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerError value)? serverError,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(TokenExpired value)? tokenExpired,
    TResult Function(UserNotFound value)? userNotFound,
    TResult Function(NotSignedIn value)? notSignedIn,
    TResult Function(AccountSuspended value)? accountSuspended,
    TResult Function(WrongPassword value)? wrongPassword,
    TResult Function(WrongUsername value)? wrongUsername,
    TResult Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (usernameAlreadyInUse != null) {
      return usernameAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class UsernameAlreadyInUse implements AuthFailure {
  const factory UsernameAlreadyInUse() = _$UsernameAlreadyInUseImpl;
}

/// @nodoc
abstract class _$$TokenExpiredImplCopyWith<$Res> {
  factory _$$TokenExpiredImplCopyWith(
          _$TokenExpiredImpl value, $Res Function(_$TokenExpiredImpl) then) =
      __$$TokenExpiredImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TokenExpiredImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$TokenExpiredImpl>
    implements _$$TokenExpiredImplCopyWith<$Res> {
  __$$TokenExpiredImplCopyWithImpl(
      _$TokenExpiredImpl _value, $Res Function(_$TokenExpiredImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TokenExpiredImpl implements TokenExpired {
  const _$TokenExpiredImpl();

  @override
  String toString() {
    return 'AuthFailure.tokenExpired()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TokenExpiredImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailOrPassword,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() tokenExpired,
    required TResult Function() userNotFound,
    required TResult Function() notSignedIn,
    required TResult Function() accountSuspended,
    required TResult Function() wrongPassword,
    required TResult Function() wrongUsername,
    required TResult Function() passwordsDoesntMatch,
    required TResult Function() wrongEmail,
  }) {
    return tokenExpired();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? serverError,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailOrPassword,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? tokenExpired,
    TResult? Function()? userNotFound,
    TResult? Function()? notSignedIn,
    TResult? Function()? accountSuspended,
    TResult? Function()? wrongPassword,
    TResult? Function()? wrongUsername,
    TResult? Function()? passwordsDoesntMatch,
    TResult? Function()? wrongEmail,
  }) {
    return tokenExpired?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailOrPassword,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? tokenExpired,
    TResult Function()? userNotFound,
    TResult Function()? notSignedIn,
    TResult Function()? accountSuspended,
    TResult Function()? wrongPassword,
    TResult Function()? wrongUsername,
    TResult Function()? passwordsDoesntMatch,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (tokenExpired != null) {
      return tokenExpired();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerError value) serverError,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(InvalidEmailOrPassword value)
        invalidEmailOrPassword,
    required TResult Function(UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(TokenExpired value) tokenExpired,
    required TResult Function(UserNotFound value) userNotFound,
    required TResult Function(NotSignedIn value) notSignedIn,
    required TResult Function(AccountSuspended value) accountSuspended,
    required TResult Function(WrongPassword value) wrongPassword,
    required TResult Function(WrongUsername value) wrongUsername,
    required TResult Function(PasswordsDoesntMatch value) passwordsDoesntMatch,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return tokenExpired(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServerError value)? serverError,
    TResult? Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult? Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(TokenExpired value)? tokenExpired,
    TResult? Function(UserNotFound value)? userNotFound,
    TResult? Function(NotSignedIn value)? notSignedIn,
    TResult? Function(AccountSuspended value)? accountSuspended,
    TResult? Function(WrongPassword value)? wrongPassword,
    TResult? Function(WrongUsername value)? wrongUsername,
    TResult? Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult? Function(WrongEmail value)? wrongEmail,
  }) {
    return tokenExpired?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerError value)? serverError,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(TokenExpired value)? tokenExpired,
    TResult Function(UserNotFound value)? userNotFound,
    TResult Function(NotSignedIn value)? notSignedIn,
    TResult Function(AccountSuspended value)? accountSuspended,
    TResult Function(WrongPassword value)? wrongPassword,
    TResult Function(WrongUsername value)? wrongUsername,
    TResult Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (tokenExpired != null) {
      return tokenExpired(this);
    }
    return orElse();
  }
}

abstract class TokenExpired implements AuthFailure {
  const factory TokenExpired() = _$TokenExpiredImpl;
}

/// @nodoc
abstract class _$$UserNotFoundImplCopyWith<$Res> {
  factory _$$UserNotFoundImplCopyWith(
          _$UserNotFoundImpl value, $Res Function(_$UserNotFoundImpl) then) =
      __$$UserNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserNotFoundImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$UserNotFoundImpl>
    implements _$$UserNotFoundImplCopyWith<$Res> {
  __$$UserNotFoundImplCopyWithImpl(
      _$UserNotFoundImpl _value, $Res Function(_$UserNotFoundImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserNotFoundImpl implements UserNotFound {
  const _$UserNotFoundImpl();

  @override
  String toString() {
    return 'AuthFailure.userNotFound()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailOrPassword,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() tokenExpired,
    required TResult Function() userNotFound,
    required TResult Function() notSignedIn,
    required TResult Function() accountSuspended,
    required TResult Function() wrongPassword,
    required TResult Function() wrongUsername,
    required TResult Function() passwordsDoesntMatch,
    required TResult Function() wrongEmail,
  }) {
    return userNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? serverError,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailOrPassword,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? tokenExpired,
    TResult? Function()? userNotFound,
    TResult? Function()? notSignedIn,
    TResult? Function()? accountSuspended,
    TResult? Function()? wrongPassword,
    TResult? Function()? wrongUsername,
    TResult? Function()? passwordsDoesntMatch,
    TResult? Function()? wrongEmail,
  }) {
    return userNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailOrPassword,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? tokenExpired,
    TResult Function()? userNotFound,
    TResult Function()? notSignedIn,
    TResult Function()? accountSuspended,
    TResult Function()? wrongPassword,
    TResult Function()? wrongUsername,
    TResult Function()? passwordsDoesntMatch,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (userNotFound != null) {
      return userNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerError value) serverError,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(InvalidEmailOrPassword value)
        invalidEmailOrPassword,
    required TResult Function(UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(TokenExpired value) tokenExpired,
    required TResult Function(UserNotFound value) userNotFound,
    required TResult Function(NotSignedIn value) notSignedIn,
    required TResult Function(AccountSuspended value) accountSuspended,
    required TResult Function(WrongPassword value) wrongPassword,
    required TResult Function(WrongUsername value) wrongUsername,
    required TResult Function(PasswordsDoesntMatch value) passwordsDoesntMatch,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return userNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServerError value)? serverError,
    TResult? Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult? Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(TokenExpired value)? tokenExpired,
    TResult? Function(UserNotFound value)? userNotFound,
    TResult? Function(NotSignedIn value)? notSignedIn,
    TResult? Function(AccountSuspended value)? accountSuspended,
    TResult? Function(WrongPassword value)? wrongPassword,
    TResult? Function(WrongUsername value)? wrongUsername,
    TResult? Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult? Function(WrongEmail value)? wrongEmail,
  }) {
    return userNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerError value)? serverError,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(TokenExpired value)? tokenExpired,
    TResult Function(UserNotFound value)? userNotFound,
    TResult Function(NotSignedIn value)? notSignedIn,
    TResult Function(AccountSuspended value)? accountSuspended,
    TResult Function(WrongPassword value)? wrongPassword,
    TResult Function(WrongUsername value)? wrongUsername,
    TResult Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (userNotFound != null) {
      return userNotFound(this);
    }
    return orElse();
  }
}

abstract class UserNotFound implements AuthFailure {
  const factory UserNotFound() = _$UserNotFoundImpl;
}

/// @nodoc
abstract class _$$NotSignedInImplCopyWith<$Res> {
  factory _$$NotSignedInImplCopyWith(
          _$NotSignedInImpl value, $Res Function(_$NotSignedInImpl) then) =
      __$$NotSignedInImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotSignedInImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$NotSignedInImpl>
    implements _$$NotSignedInImplCopyWith<$Res> {
  __$$NotSignedInImplCopyWithImpl(
      _$NotSignedInImpl _value, $Res Function(_$NotSignedInImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotSignedInImpl implements NotSignedIn {
  const _$NotSignedInImpl();

  @override
  String toString() {
    return 'AuthFailure.notSignedIn()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NotSignedInImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailOrPassword,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() tokenExpired,
    required TResult Function() userNotFound,
    required TResult Function() notSignedIn,
    required TResult Function() accountSuspended,
    required TResult Function() wrongPassword,
    required TResult Function() wrongUsername,
    required TResult Function() passwordsDoesntMatch,
    required TResult Function() wrongEmail,
  }) {
    return notSignedIn();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? serverError,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailOrPassword,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? tokenExpired,
    TResult? Function()? userNotFound,
    TResult? Function()? notSignedIn,
    TResult? Function()? accountSuspended,
    TResult? Function()? wrongPassword,
    TResult? Function()? wrongUsername,
    TResult? Function()? passwordsDoesntMatch,
    TResult? Function()? wrongEmail,
  }) {
    return notSignedIn?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailOrPassword,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? tokenExpired,
    TResult Function()? userNotFound,
    TResult Function()? notSignedIn,
    TResult Function()? accountSuspended,
    TResult Function()? wrongPassword,
    TResult Function()? wrongUsername,
    TResult Function()? passwordsDoesntMatch,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (notSignedIn != null) {
      return notSignedIn();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerError value) serverError,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(InvalidEmailOrPassword value)
        invalidEmailOrPassword,
    required TResult Function(UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(TokenExpired value) tokenExpired,
    required TResult Function(UserNotFound value) userNotFound,
    required TResult Function(NotSignedIn value) notSignedIn,
    required TResult Function(AccountSuspended value) accountSuspended,
    required TResult Function(WrongPassword value) wrongPassword,
    required TResult Function(WrongUsername value) wrongUsername,
    required TResult Function(PasswordsDoesntMatch value) passwordsDoesntMatch,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return notSignedIn(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServerError value)? serverError,
    TResult? Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult? Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(TokenExpired value)? tokenExpired,
    TResult? Function(UserNotFound value)? userNotFound,
    TResult? Function(NotSignedIn value)? notSignedIn,
    TResult? Function(AccountSuspended value)? accountSuspended,
    TResult? Function(WrongPassword value)? wrongPassword,
    TResult? Function(WrongUsername value)? wrongUsername,
    TResult? Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult? Function(WrongEmail value)? wrongEmail,
  }) {
    return notSignedIn?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerError value)? serverError,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(TokenExpired value)? tokenExpired,
    TResult Function(UserNotFound value)? userNotFound,
    TResult Function(NotSignedIn value)? notSignedIn,
    TResult Function(AccountSuspended value)? accountSuspended,
    TResult Function(WrongPassword value)? wrongPassword,
    TResult Function(WrongUsername value)? wrongUsername,
    TResult Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (notSignedIn != null) {
      return notSignedIn(this);
    }
    return orElse();
  }
}

abstract class NotSignedIn implements AuthFailure {
  const factory NotSignedIn() = _$NotSignedInImpl;
}

/// @nodoc
abstract class _$$AccountSuspendedImplCopyWith<$Res> {
  factory _$$AccountSuspendedImplCopyWith(_$AccountSuspendedImpl value,
          $Res Function(_$AccountSuspendedImpl) then) =
      __$$AccountSuspendedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AccountSuspendedImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$AccountSuspendedImpl>
    implements _$$AccountSuspendedImplCopyWith<$Res> {
  __$$AccountSuspendedImplCopyWithImpl(_$AccountSuspendedImpl _value,
      $Res Function(_$AccountSuspendedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AccountSuspendedImpl implements AccountSuspended {
  const _$AccountSuspendedImpl();

  @override
  String toString() {
    return 'AuthFailure.accountSuspended()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AccountSuspendedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailOrPassword,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() tokenExpired,
    required TResult Function() userNotFound,
    required TResult Function() notSignedIn,
    required TResult Function() accountSuspended,
    required TResult Function() wrongPassword,
    required TResult Function() wrongUsername,
    required TResult Function() passwordsDoesntMatch,
    required TResult Function() wrongEmail,
  }) {
    return accountSuspended();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? serverError,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailOrPassword,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? tokenExpired,
    TResult? Function()? userNotFound,
    TResult? Function()? notSignedIn,
    TResult? Function()? accountSuspended,
    TResult? Function()? wrongPassword,
    TResult? Function()? wrongUsername,
    TResult? Function()? passwordsDoesntMatch,
    TResult? Function()? wrongEmail,
  }) {
    return accountSuspended?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailOrPassword,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? tokenExpired,
    TResult Function()? userNotFound,
    TResult Function()? notSignedIn,
    TResult Function()? accountSuspended,
    TResult Function()? wrongPassword,
    TResult Function()? wrongUsername,
    TResult Function()? passwordsDoesntMatch,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (accountSuspended != null) {
      return accountSuspended();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerError value) serverError,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(InvalidEmailOrPassword value)
        invalidEmailOrPassword,
    required TResult Function(UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(TokenExpired value) tokenExpired,
    required TResult Function(UserNotFound value) userNotFound,
    required TResult Function(NotSignedIn value) notSignedIn,
    required TResult Function(AccountSuspended value) accountSuspended,
    required TResult Function(WrongPassword value) wrongPassword,
    required TResult Function(WrongUsername value) wrongUsername,
    required TResult Function(PasswordsDoesntMatch value) passwordsDoesntMatch,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return accountSuspended(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServerError value)? serverError,
    TResult? Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult? Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(TokenExpired value)? tokenExpired,
    TResult? Function(UserNotFound value)? userNotFound,
    TResult? Function(NotSignedIn value)? notSignedIn,
    TResult? Function(AccountSuspended value)? accountSuspended,
    TResult? Function(WrongPassword value)? wrongPassword,
    TResult? Function(WrongUsername value)? wrongUsername,
    TResult? Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult? Function(WrongEmail value)? wrongEmail,
  }) {
    return accountSuspended?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerError value)? serverError,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(TokenExpired value)? tokenExpired,
    TResult Function(UserNotFound value)? userNotFound,
    TResult Function(NotSignedIn value)? notSignedIn,
    TResult Function(AccountSuspended value)? accountSuspended,
    TResult Function(WrongPassword value)? wrongPassword,
    TResult Function(WrongUsername value)? wrongUsername,
    TResult Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (accountSuspended != null) {
      return accountSuspended(this);
    }
    return orElse();
  }
}

abstract class AccountSuspended implements AuthFailure {
  const factory AccountSuspended() = _$AccountSuspendedImpl;
}

/// @nodoc
abstract class _$$WrongPasswordImplCopyWith<$Res> {
  factory _$$WrongPasswordImplCopyWith(
          _$WrongPasswordImpl value, $Res Function(_$WrongPasswordImpl) then) =
      __$$WrongPasswordImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WrongPasswordImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$WrongPasswordImpl>
    implements _$$WrongPasswordImplCopyWith<$Res> {
  __$$WrongPasswordImplCopyWithImpl(
      _$WrongPasswordImpl _value, $Res Function(_$WrongPasswordImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WrongPasswordImpl implements WrongPassword {
  const _$WrongPasswordImpl();

  @override
  String toString() {
    return 'AuthFailure.wrongPassword()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WrongPasswordImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailOrPassword,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() tokenExpired,
    required TResult Function() userNotFound,
    required TResult Function() notSignedIn,
    required TResult Function() accountSuspended,
    required TResult Function() wrongPassword,
    required TResult Function() wrongUsername,
    required TResult Function() passwordsDoesntMatch,
    required TResult Function() wrongEmail,
  }) {
    return wrongPassword();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? serverError,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailOrPassword,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? tokenExpired,
    TResult? Function()? userNotFound,
    TResult? Function()? notSignedIn,
    TResult? Function()? accountSuspended,
    TResult? Function()? wrongPassword,
    TResult? Function()? wrongUsername,
    TResult? Function()? passwordsDoesntMatch,
    TResult? Function()? wrongEmail,
  }) {
    return wrongPassword?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailOrPassword,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? tokenExpired,
    TResult Function()? userNotFound,
    TResult Function()? notSignedIn,
    TResult Function()? accountSuspended,
    TResult Function()? wrongPassword,
    TResult Function()? wrongUsername,
    TResult Function()? passwordsDoesntMatch,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (wrongPassword != null) {
      return wrongPassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerError value) serverError,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(InvalidEmailOrPassword value)
        invalidEmailOrPassword,
    required TResult Function(UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(TokenExpired value) tokenExpired,
    required TResult Function(UserNotFound value) userNotFound,
    required TResult Function(NotSignedIn value) notSignedIn,
    required TResult Function(AccountSuspended value) accountSuspended,
    required TResult Function(WrongPassword value) wrongPassword,
    required TResult Function(WrongUsername value) wrongUsername,
    required TResult Function(PasswordsDoesntMatch value) passwordsDoesntMatch,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return wrongPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServerError value)? serverError,
    TResult? Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult? Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(TokenExpired value)? tokenExpired,
    TResult? Function(UserNotFound value)? userNotFound,
    TResult? Function(NotSignedIn value)? notSignedIn,
    TResult? Function(AccountSuspended value)? accountSuspended,
    TResult? Function(WrongPassword value)? wrongPassword,
    TResult? Function(WrongUsername value)? wrongUsername,
    TResult? Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult? Function(WrongEmail value)? wrongEmail,
  }) {
    return wrongPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerError value)? serverError,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(TokenExpired value)? tokenExpired,
    TResult Function(UserNotFound value)? userNotFound,
    TResult Function(NotSignedIn value)? notSignedIn,
    TResult Function(AccountSuspended value)? accountSuspended,
    TResult Function(WrongPassword value)? wrongPassword,
    TResult Function(WrongUsername value)? wrongUsername,
    TResult Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (wrongPassword != null) {
      return wrongPassword(this);
    }
    return orElse();
  }
}

abstract class WrongPassword implements AuthFailure {
  const factory WrongPassword() = _$WrongPasswordImpl;
}

/// @nodoc
abstract class _$$WrongUsernameImplCopyWith<$Res> {
  factory _$$WrongUsernameImplCopyWith(
          _$WrongUsernameImpl value, $Res Function(_$WrongUsernameImpl) then) =
      __$$WrongUsernameImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WrongUsernameImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$WrongUsernameImpl>
    implements _$$WrongUsernameImplCopyWith<$Res> {
  __$$WrongUsernameImplCopyWithImpl(
      _$WrongUsernameImpl _value, $Res Function(_$WrongUsernameImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WrongUsernameImpl implements WrongUsername {
  const _$WrongUsernameImpl();

  @override
  String toString() {
    return 'AuthFailure.wrongUsername()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WrongUsernameImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailOrPassword,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() tokenExpired,
    required TResult Function() userNotFound,
    required TResult Function() notSignedIn,
    required TResult Function() accountSuspended,
    required TResult Function() wrongPassword,
    required TResult Function() wrongUsername,
    required TResult Function() passwordsDoesntMatch,
    required TResult Function() wrongEmail,
  }) {
    return wrongUsername();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? serverError,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailOrPassword,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? tokenExpired,
    TResult? Function()? userNotFound,
    TResult? Function()? notSignedIn,
    TResult? Function()? accountSuspended,
    TResult? Function()? wrongPassword,
    TResult? Function()? wrongUsername,
    TResult? Function()? passwordsDoesntMatch,
    TResult? Function()? wrongEmail,
  }) {
    return wrongUsername?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailOrPassword,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? tokenExpired,
    TResult Function()? userNotFound,
    TResult Function()? notSignedIn,
    TResult Function()? accountSuspended,
    TResult Function()? wrongPassword,
    TResult Function()? wrongUsername,
    TResult Function()? passwordsDoesntMatch,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (wrongUsername != null) {
      return wrongUsername();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerError value) serverError,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(InvalidEmailOrPassword value)
        invalidEmailOrPassword,
    required TResult Function(UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(TokenExpired value) tokenExpired,
    required TResult Function(UserNotFound value) userNotFound,
    required TResult Function(NotSignedIn value) notSignedIn,
    required TResult Function(AccountSuspended value) accountSuspended,
    required TResult Function(WrongPassword value) wrongPassword,
    required TResult Function(WrongUsername value) wrongUsername,
    required TResult Function(PasswordsDoesntMatch value) passwordsDoesntMatch,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return wrongUsername(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServerError value)? serverError,
    TResult? Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult? Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(TokenExpired value)? tokenExpired,
    TResult? Function(UserNotFound value)? userNotFound,
    TResult? Function(NotSignedIn value)? notSignedIn,
    TResult? Function(AccountSuspended value)? accountSuspended,
    TResult? Function(WrongPassword value)? wrongPassword,
    TResult? Function(WrongUsername value)? wrongUsername,
    TResult? Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult? Function(WrongEmail value)? wrongEmail,
  }) {
    return wrongUsername?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerError value)? serverError,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(TokenExpired value)? tokenExpired,
    TResult Function(UserNotFound value)? userNotFound,
    TResult Function(NotSignedIn value)? notSignedIn,
    TResult Function(AccountSuspended value)? accountSuspended,
    TResult Function(WrongPassword value)? wrongPassword,
    TResult Function(WrongUsername value)? wrongUsername,
    TResult Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (wrongUsername != null) {
      return wrongUsername(this);
    }
    return orElse();
  }
}

abstract class WrongUsername implements AuthFailure {
  const factory WrongUsername() = _$WrongUsernameImpl;
}

/// @nodoc
abstract class _$$PasswordsDoesntMatchImplCopyWith<$Res> {
  factory _$$PasswordsDoesntMatchImplCopyWith(_$PasswordsDoesntMatchImpl value,
          $Res Function(_$PasswordsDoesntMatchImpl) then) =
      __$$PasswordsDoesntMatchImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PasswordsDoesntMatchImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$PasswordsDoesntMatchImpl>
    implements _$$PasswordsDoesntMatchImplCopyWith<$Res> {
  __$$PasswordsDoesntMatchImplCopyWithImpl(_$PasswordsDoesntMatchImpl _value,
      $Res Function(_$PasswordsDoesntMatchImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PasswordsDoesntMatchImpl implements PasswordsDoesntMatch {
  const _$PasswordsDoesntMatchImpl();

  @override
  String toString() {
    return 'AuthFailure.passwordsDoesntMatch()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PasswordsDoesntMatchImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailOrPassword,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() tokenExpired,
    required TResult Function() userNotFound,
    required TResult Function() notSignedIn,
    required TResult Function() accountSuspended,
    required TResult Function() wrongPassword,
    required TResult Function() wrongUsername,
    required TResult Function() passwordsDoesntMatch,
    required TResult Function() wrongEmail,
  }) {
    return passwordsDoesntMatch();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? serverError,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailOrPassword,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? tokenExpired,
    TResult? Function()? userNotFound,
    TResult? Function()? notSignedIn,
    TResult? Function()? accountSuspended,
    TResult? Function()? wrongPassword,
    TResult? Function()? wrongUsername,
    TResult? Function()? passwordsDoesntMatch,
    TResult? Function()? wrongEmail,
  }) {
    return passwordsDoesntMatch?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailOrPassword,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? tokenExpired,
    TResult Function()? userNotFound,
    TResult Function()? notSignedIn,
    TResult Function()? accountSuspended,
    TResult Function()? wrongPassword,
    TResult Function()? wrongUsername,
    TResult Function()? passwordsDoesntMatch,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (passwordsDoesntMatch != null) {
      return passwordsDoesntMatch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerError value) serverError,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(InvalidEmailOrPassword value)
        invalidEmailOrPassword,
    required TResult Function(UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(TokenExpired value) tokenExpired,
    required TResult Function(UserNotFound value) userNotFound,
    required TResult Function(NotSignedIn value) notSignedIn,
    required TResult Function(AccountSuspended value) accountSuspended,
    required TResult Function(WrongPassword value) wrongPassword,
    required TResult Function(WrongUsername value) wrongUsername,
    required TResult Function(PasswordsDoesntMatch value) passwordsDoesntMatch,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return passwordsDoesntMatch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServerError value)? serverError,
    TResult? Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult? Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(TokenExpired value)? tokenExpired,
    TResult? Function(UserNotFound value)? userNotFound,
    TResult? Function(NotSignedIn value)? notSignedIn,
    TResult? Function(AccountSuspended value)? accountSuspended,
    TResult? Function(WrongPassword value)? wrongPassword,
    TResult? Function(WrongUsername value)? wrongUsername,
    TResult? Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult? Function(WrongEmail value)? wrongEmail,
  }) {
    return passwordsDoesntMatch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerError value)? serverError,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(TokenExpired value)? tokenExpired,
    TResult Function(UserNotFound value)? userNotFound,
    TResult Function(NotSignedIn value)? notSignedIn,
    TResult Function(AccountSuspended value)? accountSuspended,
    TResult Function(WrongPassword value)? wrongPassword,
    TResult Function(WrongUsername value)? wrongUsername,
    TResult Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (passwordsDoesntMatch != null) {
      return passwordsDoesntMatch(this);
    }
    return orElse();
  }
}

abstract class PasswordsDoesntMatch implements AuthFailure {
  const factory PasswordsDoesntMatch() = _$PasswordsDoesntMatchImpl;
}

/// @nodoc
abstract class _$$WrongEmailImplCopyWith<$Res> {
  factory _$$WrongEmailImplCopyWith(
          _$WrongEmailImpl value, $Res Function(_$WrongEmailImpl) then) =
      __$$WrongEmailImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WrongEmailImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$WrongEmailImpl>
    implements _$$WrongEmailImplCopyWith<$Res> {
  __$$WrongEmailImplCopyWithImpl(
      _$WrongEmailImpl _value, $Res Function(_$WrongEmailImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WrongEmailImpl implements WrongEmail {
  const _$WrongEmailImpl();

  @override
  String toString() {
    return 'AuthFailure.wrongEmail()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WrongEmailImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailOrPassword,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() tokenExpired,
    required TResult Function() userNotFound,
    required TResult Function() notSignedIn,
    required TResult Function() accountSuspended,
    required TResult Function() wrongPassword,
    required TResult Function() wrongUsername,
    required TResult Function() passwordsDoesntMatch,
    required TResult Function() wrongEmail,
  }) {
    return wrongEmail();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? serverError,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailOrPassword,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? tokenExpired,
    TResult? Function()? userNotFound,
    TResult? Function()? notSignedIn,
    TResult? Function()? accountSuspended,
    TResult? Function()? wrongPassword,
    TResult? Function()? wrongUsername,
    TResult? Function()? passwordsDoesntMatch,
    TResult? Function()? wrongEmail,
  }) {
    return wrongEmail?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailOrPassword,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? tokenExpired,
    TResult Function()? userNotFound,
    TResult Function()? notSignedIn,
    TResult Function()? accountSuspended,
    TResult Function()? wrongPassword,
    TResult Function()? wrongUsername,
    TResult Function()? passwordsDoesntMatch,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (wrongEmail != null) {
      return wrongEmail();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerError value) serverError,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(InvalidEmailOrPassword value)
        invalidEmailOrPassword,
    required TResult Function(UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(TokenExpired value) tokenExpired,
    required TResult Function(UserNotFound value) userNotFound,
    required TResult Function(NotSignedIn value) notSignedIn,
    required TResult Function(AccountSuspended value) accountSuspended,
    required TResult Function(WrongPassword value) wrongPassword,
    required TResult Function(WrongUsername value) wrongUsername,
    required TResult Function(PasswordsDoesntMatch value) passwordsDoesntMatch,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return wrongEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServerError value)? serverError,
    TResult? Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult? Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(TokenExpired value)? tokenExpired,
    TResult? Function(UserNotFound value)? userNotFound,
    TResult? Function(NotSignedIn value)? notSignedIn,
    TResult? Function(AccountSuspended value)? accountSuspended,
    TResult? Function(WrongPassword value)? wrongPassword,
    TResult? Function(WrongUsername value)? wrongUsername,
    TResult? Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult? Function(WrongEmail value)? wrongEmail,
  }) {
    return wrongEmail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerError value)? serverError,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(InvalidEmailOrPassword value)? invalidEmailOrPassword,
    TResult Function(UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(TokenExpired value)? tokenExpired,
    TResult Function(UserNotFound value)? userNotFound,
    TResult Function(NotSignedIn value)? notSignedIn,
    TResult Function(AccountSuspended value)? accountSuspended,
    TResult Function(WrongPassword value)? wrongPassword,
    TResult Function(WrongUsername value)? wrongUsername,
    TResult Function(PasswordsDoesntMatch value)? passwordsDoesntMatch,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (wrongEmail != null) {
      return wrongEmail(this);
    }
    return orElse();
  }
}

abstract class WrongEmail implements AuthFailure {
  const factory WrongEmail() = _$WrongEmailImpl;
}
